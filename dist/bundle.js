/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./bartender.js":
/*!**********************!*\
  !*** ./bartender.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _huggingface_inference__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @huggingface/inference */ \"./node_modules/@huggingface/inference/dist/index.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction _asyncIterator(r) { var n, t, o, e = 2; for (\"undefined\" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) { if (t && null != (n = r[t])) return n.call(r); if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r)); t = \"@@asyncIterator\", o = \"@@iterator\"; } throw new TypeError(\"Object is not async iterable\"); }\nfunction AsyncFromSyncIterator(r) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\")); var n = r.done; return Promise.resolve(r.value).then(function (r) { return { value: r, done: n }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(r) { this.s = r, this.n = r.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, \"return\": function _return(r) { var n = this.s[\"return\"]; return void 0 === n ? Promise.resolve({ value: r, done: !0 }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); }, \"throw\": function _throw(r) { var n = this.s[\"return\"]; return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(r); }\n\nvar client = new _huggingface_inference__WEBPACK_IMPORTED_MODULE_0__.HfInference(\"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\");\nfunction displayRecommendations(recommendations) {\n  //     console.log(\"Recommendations:\\n\", recommendations);\n\n  //     // Check if recommendations is a string and parse it into JSON if necessary\n  //     if (typeof recommendations === 'string') {\n  //         recommendations = JSON.parse(recommendations);\n  //     }\n\n  //     const outputDiv = document.getElementById(\"output\");\n  //     outputDiv.innerHTML = '';  // Clear previous output\n\n  //     // Check if recommendations is an array now\n  //     if (!Array.isArray(recommendations)) {\n  //         console.error(\"Expected an array but got:\", recommendations);\n  //         outputDiv.innerText = \"Error: Unable to display recommendations.\";\n  //         return;\n  //     }\n\n  console.log(\"Recommendations:\\n\", recommendations);\n\n  // Initialize a variable to store any additional notes or appended text\n  var additionalNotes = '';\n\n  // Check if recommendations is a string and parse it into JSON if necessary\n  if (typeof recommendations === 'string') {\n    // Find the position of the last closing bracket \"]\"\n    var jsonEndIndex = recommendations.lastIndexOf(']') + 1;\n\n    // Extract the valid JSON part\n    var validJsonString = recommendations.slice(0, jsonEndIndex);\n\n    // Capture any additional notes or trailing text after the valid JSON\n    additionalNotes = recommendations.slice(jsonEndIndex).trim();\n\n    // Parse the valid JSON part\n    try {\n      recommendations = JSON.parse(validJsonString);\n    } catch (error) {\n      console.error(\"Error parsing JSON:\", error);\n      document.getElementById(\"output\").innerText = \"Error: Invalid JSON received.\";\n      return;\n    }\n  }\n  var outputDiv = document.getElementById(\"output\");\n  outputDiv.innerHTML = ''; // Clear previous output\n\n  // Check if recommendations is an array now\n  if (!Array.isArray(recommendations)) {\n    console.error(\"Expected an array but got:\", recommendations);\n    outputDiv.innerText = \"Error: Unable to display recommendations.\";\n    return;\n  }\n\n  // Display any additional notes or trailing text\n  if (additionalNotes) {\n    var notesDiv = document.createElement(\"div\");\n    notesDiv.style.marginTop = \"20px\";\n    notesDiv.innerText = additionalNotes;\n    outputDiv.appendChild(notesDiv);\n  }\n\n  // Loop through the JSON data (recommendations)\n  recommendations.forEach(function (item) {\n    // Create a div to hold each item\n    var itemDiv = document.createElement(\"div\");\n    itemDiv.style.border = \"1px solid #ccc\";\n    itemDiv.style.padding = \"10px\";\n    itemDiv.style.margin = \"10px\";\n    // itemDiv.style.backgroundColor = \"#f9f9f9\";  // Light background color\n\n    // Create a table to display the details of each recommendation\n    var table = document.createElement(\"table\");\n    table.style.width = \"100%\";\n    table.style.borderCollapse = \"collapse\";\n\n    // Helper function to create a table row\n    function addTableRow(label, value) {\n      var row = table.insertRow();\n      var cell1 = row.insertCell(0);\n      var cell2 = row.insertCell(1);\n      cell1.style.border = \"1px solid #ddd\";\n      cell1.style.padding = \"8px\";\n      cell2.style.border = \"1px solid #ddd\";\n      cell2.style.padding = \"8px\";\n      cell1.innerText = label;\n      cell2.innerText = value;\n    }\n\n    // Add rows for each item in the recommendation\n    addTableRow(\"Type\", item.Type);\n    addTableRow(\"Name\", item.Name);\n    addTableRow(\"Ingredients and flavors\", item[\"Ingredients and flavors\"] || \"N/A\");\n    addTableRow(\"Origin\", item.Origin || \"N/A\");\n    addTableRow(\"Price\", item.Price || \"N/A\");\n    addTableRow(\"Has Alcohol\", item.Has_alcohol ? \"Yes\" : \"No\");\n    addTableRow(\"Flavor\", item.Flavor || \"N/A\");\n    addTableRow(\"On Menu\", item.On_menu || \"N/A\");\n\n    // Append the table to the item div\n    itemDiv.appendChild(table);\n\n    // Append the item div to the outputDiv\n    outputDiv.appendChild(itemDiv);\n  });\n}\ndocument.getElementById('submit-btn').addEventListener('click', function () {\n  var _document$querySelect;\n  // Get selected items from \"Type\" checkboxes\n  var selectedTypes = [];\n  var typeCheckboxes = [\"type-cocktails\", \"type-seasonal-drinks\", \"type-zero-proof\", \"type-sparkling-wine\", \"type-red-wine\", \"type-white-rose-wine\"];\n  typeCheckboxes.forEach(function (id) {\n    var checkbox = document.getElementById(id);\n    if (checkbox.checked) {\n      selectedTypes.push(checkbox.value);\n    }\n  });\n\n  // Get selected items from \"Flavors\" checkboxes\n  var selectedFlavors = [];\n  var flavorCheckboxes = [\"flavor-fruity\", \"flavor-spicy\", \"flavor-dry\", \"flavor-creamy\", \"flavor-refreshing\", \"flavor-gin\", \"flavor-vodka\", \"flavor-bourbon\", \"flavor-rum\", \"flavor-whiskey\", \"flavor-brandy\", \"flavor-absinthe\", \"flavor-triple-sec\", \"flavor-elderflower-liqueur\", \"flavor-limoncello\", \"flavor-peppermint-schnapps\", \"flavor-coffee-liqueur\", \"flavor-blue-curacao\", \"flavor-amaretto\", \"flavor-chili-infused-tequila\", \"flavor-sour-apple-schnapps\", \"flavor-cinnamon-syrup\", \"flavor-blackberry-puree\", \"flavor-vanilla-bean\"];\n  flavorCheckboxes.forEach(function (id) {\n    var checkbox = document.getElementById(id);\n    if (checkbox.checked) {\n      selectedFlavors.push(checkbox.value);\n    }\n  });\n\n  // Get selected item from \"Alcohol\" radio buttons\n  var selectedAlcohol = ((_document$querySelect = document.querySelector('input[name=\"alcohol\"]:checked')) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.value) || 'true'; // Default to \"with alcohol\" if none selected\n\n  // Create an object with the selected values\n  var userPreferences = {\n    Type: selectedTypes,\n    Flavor: selectedFlavors,\n    Has_alcohol: selectedAlcohol === 'true'\n  };\n  console.log(\"User preferences:\", userPreferences);\n\n  // Send the preferences to the chatbot (call your function here)\n  runScript(userPreferences);\n});\nfunction runScript(_x) {\n  return _runScript.apply(this, arguments);\n}\nfunction _runScript() {\n  _runScript = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(preferences) {\n    var out, stream, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk, newContent;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          console.log(\"Running script with preferences:\", preferences);\n          _context.prev = 1;\n          document.getElementById(\"output\").innerText = \"Loading...\";\n          out = \"\";\n          stream = client.chatCompletionStream({\n            model: \"mistralai/Mistral-7B-Instruct-v0.2\",\n            messages: [\n            // { role: \"system\", content: \"\\n\" },\n            // { role: \"user\", content: \"Tell me about cats.\"}\n            {\n              role: \"system\",\n              content: \"You are a helpful bartender assistant. You will only return a JSON object with the requested information. Do not add any other commentary or text. If the drink is not on the provided menu, set 'On_menu' to 'False', and do not add a note. Format the response exactly as: [{\\\"Type\\\": \\\"\\\", \\\"Name\\\": \\\"\\\", \\\"Ingredients and flavors\\\": \\\"\\\", \\\"Origin\\\": \\\"\\\", \\\"Price\\\": \\\"\\\", \\\"Has_alcohol\\\": true/false, \\\"Flavor\\\": \\\"\\\"}] [\\n{\\n\\\"Type\\\": \\\"\\\",\\n\\\"Name\\\": \\\"\\\",\\n\\\"Ingredients and flavors\\\": \\\"\\\",\\n\\\"Origin\\\": \\\"\\\",\\n\\\"Price\\\": \\\"\\\",\\n\\\"Has_alcohol\\\": \\\"\\\",\\n\\\"Flavor\\\": \\\"\\\",\\n\\\"On_menu\\\": \\\"\\\"}\\n].\"\n            }, {\n              role: \"user\",\n              content: \"The following is a drinks menu from a restaurant in CSV format:\\n\\nType,Name,Ingredients and flavors,Origin,Price,Has_alcohol\\nCocktails,Suzy's Margarita,\\\"tequila, italian orange liquor, lemon, lime, agave, orange bitters\\\",,,TRUE\\nCocktails,Flora & Fauna,\\\"cucumber vodka, elderflower liquor, rosemary, lemon\\\",,,TRUE\\nCocktails,Unusual Negroni,\\\"tequila, mezcal, italicus, luxardo bitter bianco, vermouth blanc\\\",,,TRUE\\nCocktails,You Had Me At Aloe,\\\"tequila, green chartreuse, aloe vera, lime, passionfruit\\\",,,TRUE\\nCocktails,Paloma Spritz,\\\"tequila, aperol, grapefruit, lime\\\",,,TRUE\\nCocktails,Painkiller,\\\"rum, pineapple, orange, coconut, nutmeg\\\",,,TRUE\\nSeasonal Drinks,Say Less,\\\"bourbon, mezcal, lime, pineapple, cinnamon\\\",,,TRUE\\nSeasonal Drinks,Sicilian Spritz,\\\"absolut elyx vodka, lemoncello, thyme, fever tree sicilian lemon\\\",,,TRUE\\nSeasonal Drinks,Pearfect Spritz,\\\"absolut elyx vodka, spiced pear, lemon, amaro montenegro, ginger, prosecco\\\",,,TRUE\\nSeasonal Drinks,Calabrian Cosmo,\\\"st. george citrus vodka, italicus bergamot, nebbiolo, lime\\\",,,TRUE\\nSeasonal Drinks,Smokeshow,\\\"whistlepig 10 yr. rye, brown sugar spiced syrup, smoke\\\",,,TRUE\\nSeasonal Drinks,Lychee-Licious,\\\"condessa gin, lychee, lime, butterfly pea extract\\\",,,TRUE\\nSeasonal Drinks,Amaro Daquiri,\\\"panteray dark rum, averna amaro, all spice dram, lime\\\",,,TRUE\\nZero Proof,\\\"Bitter, Spice & Everything Nice\\\",\\\"rhubarb bitter botanical, cinnamon, pineapple\\\",,,FALSE\\nZero Proof,Ruby Red,\\\"seedlip spice botanical, peppermint tea syrup, pomegranate, ginger\\\",,,FALSE\\nSparkling Wine,Brut,,\\\"william heritage, reserve, nj\\\",$15 / $60,TRUE\\nSparkling Wine,Sparkling Rose,,\\\"francois montand, jura, fr\\\",$13 / $52,TRUE\\nWhite & Rose Wine,Pinot Grigio,,\\\"tiga, it\\\",$10 / $40,TRUE\\nWhite & Rose Wine,Turbiana,,\\\"allegrini, lombardy, it\\\",$15 / $60,TRUE\\nWhite & Rose Wine,Assyrtiko,,\\\"estate argyros, aegean islands, gr\\\",$16 / $64,TRUE\\nWhite & Rose Wine,Sancerre,,\\\"crochet, loire, fr\\\",$19 / $75,TRUE\\nWhite & Rose Wine,Sauvignon Blanc,,\\\"massican, california\\\",$17 / $68,TRUE\\nWhite & Rose Wine,Chardonnay,,\\\"seghesio, ca\\\",$13 / $52,TRUE\\nWhite & Rose Wine,Sicilian Rose,,\\\"poggio anima, it\\\",$10 / $40,TRUE\\nWhite & Rose Wine,Provence Rose,,\\\"domaine ott, 'byott', fr\\\",$16 / $64,TRUE\\nRed Wine,Pinot Noir,,\\\"armand heitz, 'folie sauvage', burgundy, fr\\\",$17 / $68,TRUE\\nRed Wine,Cabernet Franc,,\\\"lameraux landing, fingerlakes, ny\\\",$11 / $44,TRUE\\nRed Wine,Barbera,,\\\"vietti, asti, piedmont, it\\\",$14 / $56,TRUE\\nRed Wine,Sangiovese,,\\\"poggio anima, tuscany, it\\\",$10 / $40,TRUE\\nRed Wine,Nebbiolo,,\\\"g.d. vajra, langhe, piedmont, it\\\",$14 / $56,TRUE\\nRed Wine,Tempranillo,,\\\"lachargo, reserve, rioja, sp\\\",$14 / $56,TRUE\\nRed Wine,Cabernet Sauvignon,,\\\"metier by delille cellars, columbia valley, wa\\\",$15 / $60,TRUE\\nRed Wine,Bordeaux Blend,,\\\"cain, nv blen, spring mountain distric, napa, ca\\\",$20 / $80,TRUE\\n\\nI will provide you with a few key words describing the drink I want, and you will return up to four recommended drinks in JSON format containing information from the menu, as well as a description of the flavor of the drink.  No other text is needed.\"\n            }, {\n              role: \"assistant\",\n              content: \"Okay, I am ready.\"\n            }, {\n              role: \"user\",\n              content: \"{\\\"Type\\\": \\\"Red Wine\\\", \\\"Flavor\\\": \\\"dry\\\"}\"\n            }, {\n              role: \"assistant\",\n              content: \"[\\n{\\n\\\"Type\\\": \\\"Red Wine\\\",\\n\\\"Name\\\": \\\"Barbera\\\",\\n\\\"Ingredients and flavors\\\": \\\"\\\",\\n\\\"Origin\\\": \\\"vietti, asti, piedmont, it\\\",\\n\\\"Price\\\": \\\"$14 / $56\\\",\\n\\\"Has_alcohol\\\": true,\\n\\\"Flavor\\\": \\\"A dry red wine with bold, fruity flavors and a slightly tart finish.\\\"\\n},\\n{\\n\\\"Type\\\": \\\"Red Wine\\\",\\n\\\"Name\\\": \\\"Sangiovese\\\",\\n\\\"Ingredients and flavors\\\": \\\"\\\",\\n\\\"Origin\\\": \\\"poggio anima, tuscany, it\\\",\\n\\\"Price\\\": \\\"$10 / $40\\\"\\n\\\"Has_alcohol\\\": true,\\n\\\"Flavor\\\": \\\"A dry red wine with a medium body and robust, savory flavors, often featuring notes of cherry and tomato.\\\",\\n\\\"On_menu\\\": \\\"True\\\"\\n}\\n]\"\n            }, {\n              role: \"user\",\n              content: \"{\\\"Type\\\": \\\"Cocktail\\\", \\\"Flavor\\\": \\\"creamy\\\"}\"\n            }, {\n              role: \"assistant\",\n              content: \"[\\n{\\n\\\"Type\\\": \\\"Cocktails\\\",\\n\\\"Name\\\": \\\"You Had Me At Aloe\\\",\\n\\\"Ingredients and flavors\\\": \\\"tequila, green chartreuse, aloe vera, lime, passionfruit\\\",\\n\\\"Origin\\\": \\\"\\\",\\n\\\"Price\\\": \\\"\\\",\\n\\\"Has_alcohol\\\": true,\\n\\\"Flavor\\\": \\\"A creamy cocktail with a sweet and savory taste, featuring the smooth texture of aloe vera and the tropical flavors of passionfruit.\\\"\\n},\\n{\\n\\\"Type\\\": \\\"Cocktails\\\",\\n\\\"Name\\\": \\\"Painkiller\\\",\\n\\\"Ingredients and flavors\\\": \\\"rum, pineapple, orange, coconut, nutmeg\\\",\\n\\\"Origin\\\": \\\"\\\",\\n\\\"Price\\\": \\\"\\\",\\n\\\"Has_alcohol\\\": true,\\n\\\"Flavor\\\": \\\"A cocktail with a rich, tropical flavor and a smooth texture thanks to the addition of coconut.\\\",\\n\\\"On_menu\\\": \\\"True\\\"\\n}\\n]\"\n            }, {\n              role: \"user\",\n              content: \"{\\\"Has_alcohol\\\": \\\"False\\\"}\"\n            }, {\n              role: \"assistant\",\n              content: \" [\\n{\\n\\\"Type\\\": \\\"Zero Proof\\\",\\n\\\"Name\\\": \\\"Bitter, Spice & Everything Nice\\\",\\n\\\"Ingredients and flavors\\\": \\\"rhubarb bitter botanical, cinnamon, pineapple\\\",\\n\\\"Origin\\\": \\\"\\\",\\n\\\"Price\\\": \\\"\\\",\\n\\\"Has_alcohol\\\": false,\\n\\\"Flavor\\\": \\\"A non-alcoholic drink with a complex, spicy flavor and a hint of sweetness from the pineapple.\\\",\\n\\\"On_menu\\\": \\\"True\\\"\\n},\\n{\\n\\\"Type\\\": \\\"Zero Proof\\\",\\n\\\"Name\\\": \\\"Ruby Red\\\",\\n\\\"Ingredients and flavors\\\": \\\"seedlip spice botanical, peppermint tea syrup, pomegranate, ginger\\\",\\n\\\"Origin\\\": \\\"\\\",\\n\\\"Price\\\": \\\"\\\",\\n\\\"Has_alcohol\\\": false,\\n\\\"Flavor\\\": \\\"A non-alcoholic drink with a fruity, slightly spicy flavor and a refreshing coolness from the peppermint tea syrup.\\\",\\n\\\"On_menu\\\": \\\"True\\\"\\n}\\n]\"\n            }, {\n              role: \"user\",\n              content: \"Types: \".concat(preferences.Type.join(', '), \", Flavors: \").concat(preferences.Flavor.join(', '), \", Alcohol: \").concat(preferences.Has_alcohol)\n            }],\n            temperature: 0.2,\n            max_tokens: 1024,\n            top_p: 0.7\n          });\n          _iteratorAbruptCompletion = false;\n          _didIteratorError = false;\n          _context.prev = 7;\n          _iterator = _asyncIterator(stream);\n        case 9:\n          _context.next = 11;\n          return _iterator.next();\n        case 11:\n          if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n            _context.next = 17;\n            break;\n          }\n          chunk = _step.value;\n          if (chunk.choices && chunk.choices.length > 0) {\n            newContent = chunk.choices[0].delta.content;\n            out += newContent;\n            // console.log(newContent);\n          }\n        case 14:\n          _iteratorAbruptCompletion = false;\n          _context.next = 9;\n          break;\n        case 17:\n          _context.next = 23;\n          break;\n        case 19:\n          _context.prev = 19;\n          _context.t0 = _context[\"catch\"](7);\n          _didIteratorError = true;\n          _iteratorError = _context.t0;\n        case 23:\n          _context.prev = 23;\n          _context.prev = 24;\n          if (!(_iteratorAbruptCompletion && _iterator[\"return\"] != null)) {\n            _context.next = 28;\n            break;\n          }\n          _context.next = 28;\n          return _iterator[\"return\"]();\n        case 28:\n          _context.prev = 28;\n          if (!_didIteratorError) {\n            _context.next = 31;\n            break;\n          }\n          throw _iteratorError;\n        case 31:\n          return _context.finish(28);\n        case 32:\n          return _context.finish(23);\n        case 33:\n          displayRecommendations(out);\n          _context.next = 40;\n          break;\n        case 36:\n          _context.prev = 36;\n          _context.t1 = _context[\"catch\"](1);\n          console.error(\"Error:\", _context.t1);\n          document.getElementById(\"output\").innerText = \"Error: Unable to process the request.  Try again, or check the console for more information.\";\n        case 40:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[1, 36], [7, 19, 23, 33], [24,, 28, 32]]);\n  }));\n  return _runScript.apply(this, arguments);\n}\nwindow.runScript = runScript;\n\n//# sourceURL=webpack:///./bartender.js?");

/***/ }),

/***/ "./node_modules/@huggingface/inference/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@huggingface/inference/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HfInference: () => (/* binding */ HfInference),\n/* harmony export */   HfInferenceEndpoint: () => (/* binding */ HfInferenceEndpoint),\n/* harmony export */   InferenceOutputError: () => (/* binding */ InferenceOutputError),\n/* harmony export */   audioClassification: () => (/* binding */ audioClassification),\n/* harmony export */   audioToAudio: () => (/* binding */ audioToAudio),\n/* harmony export */   automaticSpeechRecognition: () => (/* binding */ automaticSpeechRecognition),\n/* harmony export */   chatCompletion: () => (/* binding */ chatCompletion),\n/* harmony export */   chatCompletionStream: () => (/* binding */ chatCompletionStream),\n/* harmony export */   documentQuestionAnswering: () => (/* binding */ documentQuestionAnswering),\n/* harmony export */   featureExtraction: () => (/* binding */ featureExtraction),\n/* harmony export */   fillMask: () => (/* binding */ fillMask),\n/* harmony export */   imageClassification: () => (/* binding */ imageClassification),\n/* harmony export */   imageSegmentation: () => (/* binding */ imageSegmentation),\n/* harmony export */   imageToImage: () => (/* binding */ imageToImage),\n/* harmony export */   imageToText: () => (/* binding */ imageToText),\n/* harmony export */   objectDetection: () => (/* binding */ objectDetection),\n/* harmony export */   questionAnswering: () => (/* binding */ questionAnswering),\n/* harmony export */   request: () => (/* binding */ request),\n/* harmony export */   sentenceSimilarity: () => (/* binding */ sentenceSimilarity),\n/* harmony export */   streamingRequest: () => (/* binding */ streamingRequest),\n/* harmony export */   summarization: () => (/* binding */ summarization),\n/* harmony export */   tableQuestionAnswering: () => (/* binding */ tableQuestionAnswering),\n/* harmony export */   tabularClassification: () => (/* binding */ tabularClassification),\n/* harmony export */   tabularRegression: () => (/* binding */ tabularRegression),\n/* harmony export */   textClassification: () => (/* binding */ textClassification),\n/* harmony export */   textGeneration: () => (/* binding */ textGeneration),\n/* harmony export */   textGenerationStream: () => (/* binding */ textGenerationStream),\n/* harmony export */   textToImage: () => (/* binding */ textToImage),\n/* harmony export */   textToSpeech: () => (/* binding */ textToSpeech),\n/* harmony export */   tokenClassification: () => (/* binding */ tokenClassification),\n/* harmony export */   translation: () => (/* binding */ translation),\n/* harmony export */   visualQuestionAnswering: () => (/* binding */ visualQuestionAnswering),\n/* harmony export */   zeroShotClassification: () => (/* binding */ zeroShotClassification),\n/* harmony export */   zeroShotImageClassification: () => (/* binding */ zeroShotImageClassification)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/tasks/index.ts\nvar tasks_exports = {};\n__export(tasks_exports, {\n  audioClassification: () => audioClassification,\n  audioToAudio: () => audioToAudio,\n  automaticSpeechRecognition: () => automaticSpeechRecognition,\n  chatCompletion: () => chatCompletion,\n  chatCompletionStream: () => chatCompletionStream,\n  documentQuestionAnswering: () => documentQuestionAnswering,\n  featureExtraction: () => featureExtraction,\n  fillMask: () => fillMask,\n  imageClassification: () => imageClassification,\n  imageSegmentation: () => imageSegmentation,\n  imageToImage: () => imageToImage,\n  imageToText: () => imageToText,\n  objectDetection: () => objectDetection,\n  questionAnswering: () => questionAnswering,\n  request: () => request,\n  sentenceSimilarity: () => sentenceSimilarity,\n  streamingRequest: () => streamingRequest,\n  summarization: () => summarization,\n  tableQuestionAnswering: () => tableQuestionAnswering,\n  tabularClassification: () => tabularClassification,\n  tabularRegression: () => tabularRegression,\n  textClassification: () => textClassification,\n  textGeneration: () => textGeneration,\n  textGenerationStream: () => textGenerationStream,\n  textToImage: () => textToImage,\n  textToSpeech: () => textToSpeech,\n  tokenClassification: () => tokenClassification,\n  translation: () => translation,\n  visualQuestionAnswering: () => visualQuestionAnswering,\n  zeroShotClassification: () => zeroShotClassification,\n  zeroShotImageClassification: () => zeroShotImageClassification\n});\n\n// src/utils/pick.ts\nfunction pick(o, props) {\n  return Object.assign(\n    {},\n    ...props.map((prop) => {\n      if (o[prop] !== void 0) {\n        return { [prop]: o[prop] };\n      }\n    })\n  );\n}\n\n// src/utils/typedInclude.ts\nfunction typedInclude(arr, v) {\n  return arr.includes(v);\n}\n\n// src/utils/omit.ts\nfunction omit(o, props) {\n  const propsArr = Array.isArray(props) ? props : [props];\n  const letsKeep = Object.keys(o).filter((prop) => !typedInclude(propsArr, prop));\n  return pick(o, letsKeep);\n}\n\n// src/lib/isUrl.ts\nfunction isUrl(modelOrUrl) {\n  return /^http(s?):/.test(modelOrUrl) || modelOrUrl.startsWith(\"/\");\n}\n\n// src/lib/getDefaultTask.ts\nvar taskCache = /* @__PURE__ */ new Map();\nvar CACHE_DURATION = 10 * 60 * 1e3;\nvar MAX_CACHE_ITEMS = 1e3;\nvar HF_HUB_URL = \"https://huggingface.co\";\nasync function getDefaultTask(model, accessToken, options) {\n  if (isUrl(model)) {\n    return null;\n  }\n  const key = `${model}:${accessToken}`;\n  let cachedTask = taskCache.get(key);\n  if (cachedTask && cachedTask.date < new Date(Date.now() - CACHE_DURATION)) {\n    taskCache.delete(key);\n    cachedTask = void 0;\n  }\n  if (cachedTask === void 0) {\n    const modelTask = await (options?.fetch ?? fetch)(`${HF_HUB_URL}/api/models/${model}?expand[]=pipeline_tag`, {\n      headers: accessToken ? { Authorization: `Bearer ${accessToken}` } : {}\n    }).then((resp) => resp.json()).then((json) => json.pipeline_tag).catch(() => null);\n    if (!modelTask) {\n      return null;\n    }\n    cachedTask = { task: modelTask, date: /* @__PURE__ */ new Date() };\n    taskCache.set(key, { task: modelTask, date: /* @__PURE__ */ new Date() });\n    if (taskCache.size > MAX_CACHE_ITEMS) {\n      taskCache.delete(taskCache.keys().next().value);\n    }\n  }\n  return cachedTask.task;\n}\n\n// src/lib/makeRequestOptions.ts\nvar HF_INFERENCE_API_BASE_URL = \"https://api-inference.huggingface.co\";\nvar tasks = null;\nasync function makeRequestOptions(args, options) {\n  const { accessToken, endpointUrl, ...otherArgs } = args;\n  let { model } = args;\n  const {\n    forceTask: task,\n    includeCredentials,\n    taskHint,\n    wait_for_model,\n    use_cache,\n    dont_load_model,\n    chatCompletion: chatCompletion2\n  } = options ?? {};\n  const headers = {};\n  if (accessToken) {\n    headers[\"Authorization\"] = `Bearer ${accessToken}`;\n  }\n  if (!model && !tasks && taskHint) {\n    const res = await fetch(`${HF_HUB_URL}/api/tasks`);\n    if (res.ok) {\n      tasks = await res.json();\n    }\n  }\n  if (!model && tasks && taskHint) {\n    const taskInfo = tasks[taskHint];\n    if (taskInfo) {\n      model = taskInfo.models[0].id;\n    }\n  }\n  if (!model) {\n    throw new Error(\"No model provided, and no default model found for this task\");\n  }\n  const binary = \"data\" in args && !!args.data;\n  if (!binary) {\n    headers[\"Content-Type\"] = \"application/json\";\n  }\n  if (wait_for_model) {\n    headers[\"X-Wait-For-Model\"] = \"true\";\n  }\n  if (use_cache === false) {\n    headers[\"X-Use-Cache\"] = \"false\";\n  }\n  if (dont_load_model) {\n    headers[\"X-Load-Model\"] = \"0\";\n  }\n  let url = (() => {\n    if (endpointUrl && isUrl(model)) {\n      throw new TypeError(\"Both model and endpointUrl cannot be URLs\");\n    }\n    if (isUrl(model)) {\n      console.warn(\"Using a model URL is deprecated, please use the `endpointUrl` parameter instead\");\n      return model;\n    }\n    if (endpointUrl) {\n      return endpointUrl;\n    }\n    if (task) {\n      return `${HF_INFERENCE_API_BASE_URL}/pipeline/${task}/${model}`;\n    }\n    return `${HF_INFERENCE_API_BASE_URL}/models/${model}`;\n  })();\n  if (chatCompletion2 && !url.endsWith(\"/chat/completions\")) {\n    url += \"/v1/chat/completions\";\n  }\n  let credentials;\n  if (typeof includeCredentials === \"string\") {\n    credentials = includeCredentials;\n  } else if (includeCredentials === true) {\n    credentials = \"include\";\n  }\n  const info = {\n    headers,\n    method: \"POST\",\n    body: binary ? args.data : JSON.stringify({\n      ...otherArgs.model && isUrl(otherArgs.model) ? omit(otherArgs, \"model\") : otherArgs\n    }),\n    ...credentials && { credentials },\n    signal: options?.signal\n  };\n  return { url, info };\n}\n\n// src/tasks/custom/request.ts\nasync function request(args, options) {\n  const { url, info } = await makeRequestOptions(args, options);\n  const response = await (options?.fetch ?? fetch)(url, info);\n  if (options?.retry_on_error !== false && response.status === 503 && !options?.wait_for_model) {\n    return request(args, {\n      ...options,\n      wait_for_model: true\n    });\n  }\n  if (!response.ok) {\n    if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n      const output = await response.json();\n      if ([400, 422, 404, 500].includes(response.status) && options?.chatCompletion) {\n        throw new Error(`Server ${args.model} does not seem to support chat completion. Error: ${output.error}`);\n      }\n      if (output.error) {\n        throw new Error(JSON.stringify(output.error));\n      }\n    }\n    throw new Error(\"An error occurred while fetching the blob\");\n  }\n  if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n    return await response.json();\n  }\n  return await response.blob();\n}\n\n// src/vendor/fetch-event-source/parse.ts\nfunction getLines(onLine) {\n  let buffer;\n  let position;\n  let fieldLength;\n  let discardTrailingNewline = false;\n  return function onChunk(arr) {\n    if (buffer === void 0) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      buffer = concat(buffer, arr);\n    }\n    const bufLength = buffer.length;\n    let lineStart = 0;\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10 /* NewLine */) {\n          lineStart = ++position;\n        }\n        discardTrailingNewline = false;\n      }\n      let lineEnd = -1;\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58 /* Colon */:\n            if (fieldLength === -1) {\n              fieldLength = position - lineStart;\n            }\n            break;\n          case 13 /* CarriageReturn */:\n            discardTrailingNewline = true;\n          case 10 /* NewLine */:\n            lineEnd = position;\n            break;\n        }\n      }\n      if (lineEnd === -1) {\n        break;\n      }\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position;\n      fieldLength = -1;\n    }\n    if (lineStart === bufLength) {\n      buffer = void 0;\n    } else if (lineStart !== 0) {\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\nfunction getMessages(onId, onRetry, onMessage) {\n  let message = newMessage();\n  const decoder = new TextDecoder();\n  return function onLine(line, fieldLength) {\n    if (line.length === 0) {\n      onMessage?.(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      const field = decoder.decode(line.subarray(0, fieldLength));\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* Space */ ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n      switch (field) {\n        case \"data\":\n          message.data = message.data ? message.data + \"\\n\" + value : value;\n          break;\n        case \"event\":\n          message.event = value;\n          break;\n        case \"id\":\n          onId(message.id = value);\n          break;\n        case \"retry\":\n          const retry = parseInt(value, 10);\n          if (!isNaN(retry)) {\n            onRetry(message.retry = retry);\n          }\n          break;\n      }\n    }\n  };\n}\nfunction concat(a, b) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\nfunction newMessage() {\n  return {\n    data: \"\",\n    event: \"\",\n    id: \"\",\n    retry: void 0\n  };\n}\n\n// src/tasks/custom/streamingRequest.ts\nasync function* streamingRequest(args, options) {\n  const { url, info } = await makeRequestOptions({ ...args, stream: true }, options);\n  const response = await (options?.fetch ?? fetch)(url, info);\n  if (options?.retry_on_error !== false && response.status === 503 && !options?.wait_for_model) {\n    return yield* streamingRequest(args, {\n      ...options,\n      wait_for_model: true\n    });\n  }\n  if (!response.ok) {\n    if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n      const output = await response.json();\n      if ([400, 422, 404, 500].includes(response.status) && options?.chatCompletion) {\n        throw new Error(`Server ${args.model} does not seem to support chat completion. Error: ${output.error}`);\n      }\n      if (output.error) {\n        throw new Error(output.error);\n      }\n    }\n    throw new Error(`Server response contains error: ${response.status}`);\n  }\n  if (!response.headers.get(\"content-type\")?.startsWith(\"text/event-stream\")) {\n    throw new Error(\n      `Server does not support event stream content type, it returned ` + response.headers.get(\"content-type\")\n    );\n  }\n  if (!response.body) {\n    return;\n  }\n  const reader = response.body.getReader();\n  let events = [];\n  const onEvent = (event) => {\n    events.push(event);\n  };\n  const onChunk = getLines(\n    getMessages(\n      () => {\n      },\n      () => {\n      },\n      onEvent\n    )\n  );\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done)\n        return;\n      onChunk(value);\n      for (const event of events) {\n        if (event.data.length > 0) {\n          if (event.data === \"[DONE]\") {\n            return;\n          }\n          const data = JSON.parse(event.data);\n          if (typeof data === \"object\" && data !== null && \"error\" in data) {\n            throw new Error(data.error);\n          }\n          yield data;\n        }\n      }\n      events = [];\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n// src/lib/InferenceOutputError.ts\nvar InferenceOutputError = class extends TypeError {\n  constructor(message) {\n    super(\n      `Invalid inference output: ${message}. Use the 'request' method with the same parameters to do a custom call with no type checking.`\n    );\n    this.name = \"InferenceOutputError\";\n  }\n};\n\n// src/tasks/audio/audioClassification.ts\nasync function audioClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"audio-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/audio/automaticSpeechRecognition.ts\nasync function automaticSpeechRecognition(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"automatic-speech-recognition\"\n  });\n  const isValidOutput = typeof res?.text === \"string\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {text: string}\");\n  }\n  return res;\n}\n\n// src/tasks/audio/textToSpeech.ts\nasync function textToSpeech(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-to-speech\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/tasks/audio/audioToAudio.ts\nasync function audioToAudio(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"audio-to-audio\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.label === \"string\" && typeof x.blob === \"string\" && typeof x[\"content-type\"] === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, blob: string, content-type: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageClassification.ts\nasync function imageClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"image-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageSegmentation.ts\nasync function imageSegmentation(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"image-segmentation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.mask === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, mask: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageToText.ts\nasync function imageToText(args, options) {\n  const res = (await request(args, {\n    ...options,\n    taskHint: \"image-to-text\"\n  }))?.[0];\n  if (typeof res?.generated_text !== \"string\") {\n    throw new InferenceOutputError(\"Expected {generated_text: string}\");\n  }\n  return res;\n}\n\n// src/tasks/cv/objectDetection.ts\nasync function objectDetection(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"object-detection\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.label === \"string\" && typeof x.score === \"number\" && typeof x.box.xmin === \"number\" && typeof x.box.ymin === \"number\" && typeof x.box.xmax === \"number\" && typeof x.box.ymax === \"number\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected Array<{label:string; score:number; box:{xmin:number; ymin:number; xmax:number; ymax:number}}>\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/cv/textToImage.ts\nasync function textToImage(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-to-image\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/utils/base64FromBytes.ts\nfunction base64FromBytes(arr) {\n  if (globalThis.Buffer) {\n    return globalThis.Buffer.from(arr).toString(\"base64\");\n  } else {\n    const bin = [];\n    arr.forEach((byte) => {\n      bin.push(String.fromCharCode(byte));\n    });\n    return globalThis.btoa(bin.join(\"\"));\n  }\n}\n\n// src/tasks/cv/imageToImage.ts\nasync function imageToImage(args, options) {\n  let reqArgs;\n  if (!args.parameters) {\n    reqArgs = {\n      accessToken: args.accessToken,\n      model: args.model,\n      data: args.inputs\n    };\n  } else {\n    reqArgs = {\n      ...args,\n      inputs: base64FromBytes(\n        new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer())\n      )\n    };\n  }\n  const res = await request(reqArgs, {\n    ...options,\n    taskHint: \"image-to-image\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/tasks/cv/zeroShotImageClassification.ts\nasync function zeroShotImageClassification(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      image: base64FromBytes(\n        new Uint8Array(\n          args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()\n        )\n      )\n    }\n  };\n  const res = await request(reqArgs, {\n    ...options,\n    taskHint: \"zero-shot-image-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/featureExtraction.ts\nasync function featureExtraction(args, options) {\n  const defaultTask = args.model ? await getDefaultTask(args.model, args.accessToken, options) : void 0;\n  const res = await request(args, {\n    ...options,\n    taskHint: \"feature-extraction\",\n    ...defaultTask === \"sentence-similarity\" && { forceTask: \"feature-extraction\" }\n  });\n  let isValidOutput = true;\n  const isNumArrayRec = (arr, maxDepth, curDepth = 0) => {\n    if (curDepth > maxDepth)\n      return false;\n    if (arr.every((x) => Array.isArray(x))) {\n      return arr.every((x) => isNumArrayRec(x, maxDepth, curDepth + 1));\n    } else {\n      return arr.every((x) => typeof x === \"number\");\n    }\n  };\n  isValidOutput = Array.isArray(res) && isNumArrayRec(res, 3, 0);\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<number[][][] | number[][] | number[] | number>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/fillMask.ts\nasync function fillMask(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"fill-mask\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.score === \"number\" && typeof x.sequence === \"string\" && typeof x.token === \"number\" && typeof x.token_str === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected Array<{score: number, sequence: string, token: number, token_str: string}>\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/nlp/questionAnswering.ts\nasync function questionAnswering(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"question-answering\"\n  });\n  const isValidOutput = typeof res === \"object\" && !!res && typeof res.answer === \"string\" && typeof res.end === \"number\" && typeof res.score === \"number\" && typeof res.start === \"number\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {answer: string, end: number, score: number, start: number}\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/sentenceSimilarity.ts\nasync function sentenceSimilarity(args, options) {\n  const defaultTask = args.model ? await getDefaultTask(args.model, args.accessToken, options) : void 0;\n  const res = await request(args, {\n    ...options,\n    taskHint: \"sentence-similarity\",\n    ...defaultTask === \"feature-extraction\" && { forceTask: \"sentence-similarity\" }\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/summarization.ts\nasync function summarization(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"summarization\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.summary_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{summary_text: string}>\");\n  }\n  return res?.[0];\n}\n\n// src/tasks/nlp/tableQuestionAnswering.ts\nasync function tableQuestionAnswering(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"table-question-answering\"\n  });\n  const isValidOutput = typeof res?.aggregator === \"string\" && typeof res.answer === \"string\" && Array.isArray(res.cells) && res.cells.every((x) => typeof x === \"string\") && Array.isArray(res.coordinates) && res.coordinates.every((coord) => Array.isArray(coord) && coord.every((x) => typeof x === \"number\"));\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected {aggregator: string, answer: string, cells: string[], coordinates: number[][]}\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/nlp/textClassification.ts\nasync function textClassification(args, options) {\n  const res = (await request(args, {\n    ...options,\n    taskHint: \"text-classification\"\n  }))?.[0];\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/utils/toArray.ts\nfunction toArray(obj) {\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\n\n// src/tasks/nlp/textGeneration.ts\nasync function textGeneration(args, options) {\n  const res = toArray(\n    await request(args, {\n      ...options,\n      taskHint: \"text-generation\"\n    })\n  );\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.generated_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{generated_text: string}>\");\n  }\n  return res?.[0];\n}\n\n// src/tasks/nlp/textGenerationStream.ts\nasync function* textGenerationStream(args, options) {\n  yield* streamingRequest(args, {\n    ...options,\n    taskHint: \"text-generation\"\n  });\n}\n\n// src/tasks/nlp/tokenClassification.ts\nasync function tokenClassification(args, options) {\n  const res = toArray(\n    await request(args, {\n      ...options,\n      taskHint: \"token-classification\"\n    })\n  );\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.end === \"number\" && typeof x.entity_group === \"string\" && typeof x.score === \"number\" && typeof x.start === \"number\" && typeof x.word === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected Array<{end: number, entity_group: string, score: number, start: number, word: string}>\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/nlp/translation.ts\nasync function translation(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"translation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.translation_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected type Array<{translation_text: string}>\");\n  }\n  return res?.length === 1 ? res?.[0] : res;\n}\n\n// src/tasks/nlp/zeroShotClassification.ts\nasync function zeroShotClassification(args, options) {\n  const res = toArray(\n    await request(args, {\n      ...options,\n      taskHint: \"zero-shot-classification\"\n    })\n  );\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => Array.isArray(x.labels) && x.labels.every((_label) => typeof _label === \"string\") && Array.isArray(x.scores) && x.scores.every((_score) => typeof _score === \"number\") && typeof x.sequence === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{labels: string[], scores: number[], sequence: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/chatCompletion.ts\nasync function chatCompletion(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-generation\",\n    chatCompletion: true\n  });\n  const isValidOutput = typeof res === \"object\" && Array.isArray(res?.choices) && typeof res?.created === \"number\" && typeof res?.id === \"string\" && typeof res?.model === \"string\" && typeof res?.system_fingerprint === \"string\" && typeof res?.usage === \"object\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected ChatCompletionOutput\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/chatCompletionStream.ts\nasync function* chatCompletionStream(args, options) {\n  yield* streamingRequest(args, {\n    ...options,\n    taskHint: \"text-generation\",\n    chatCompletion: true\n  });\n}\n\n// src/tasks/multimodal/documentQuestionAnswering.ts\nasync function documentQuestionAnswering(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(\n        new Uint8Array(\n          args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()\n        )\n      )\n    }\n  };\n  const res = toArray(\n    await request(reqArgs, {\n      ...options,\n      taskHint: \"document-question-answering\"\n    })\n  )?.[0];\n  const isValidOutput = typeof res?.answer === \"string\" && (typeof res.end === \"number\" || typeof res.end === \"undefined\") && (typeof res.score === \"number\" || typeof res.score === \"undefined\") && (typeof res.start === \"number\" || typeof res.start === \"undefined\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, end?: number, score?: number, start?: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/multimodal/visualQuestionAnswering.ts\nasync function visualQuestionAnswering(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(\n        new Uint8Array(\n          args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()\n        )\n      )\n    }\n  };\n  const res = (await request(reqArgs, {\n    ...options,\n    taskHint: \"visual-question-answering\"\n  }))?.[0];\n  const isValidOutput = typeof res?.answer === \"string\" && typeof res.score === \"number\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/tabular/tabularRegression.ts\nasync function tabularRegression(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"tabular-regression\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/tasks/tabular/tabularClassification.ts\nasync function tabularClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"tabular-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/HfInference.ts\nvar HfInference = class {\n  accessToken;\n  defaultOptions;\n  constructor(accessToken = \"\", defaultOptions = {}) {\n    this.accessToken = accessToken;\n    this.defaultOptions = defaultOptions;\n    for (const [name, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name, {\n        enumerable: false,\n        value: (params, options) => (\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          fn({ ...params, accessToken }, { ...defaultOptions, ...options })\n        )\n      });\n    }\n  }\n  /**\n   * Returns copy of HfInference tied to a specified endpoint.\n   */\n  endpoint(endpointUrl) {\n    return new HfInferenceEndpoint(endpointUrl, this.accessToken, this.defaultOptions);\n  }\n};\nvar HfInferenceEndpoint = class {\n  constructor(endpointUrl, accessToken = \"\", defaultOptions = {}) {\n    accessToken;\n    defaultOptions;\n    for (const [name, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name, {\n        enumerable: false,\n        value: (params, options) => (\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          fn({ ...params, accessToken, endpointUrl }, { ...defaultOptions, ...options })\n        )\n      });\n    }\n  }\n};\n\n\n\n//# sourceURL=webpack:///./node_modules/@huggingface/inference/dist/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./bartender.js");
/******/ 	
/******/ })()
;